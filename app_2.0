import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import customtkinter as ctk
import pandas as pd
from datetime import datetime
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import win32com.client
from PIL import Image, ImageTk
import os

# Define language names
LANGUAGE_NAMES = {
    'en': 'English',
    'pl': 'Polski',
    'es': 'Español',
    'fr': 'Français',
    'it': 'Italiano',
    'pt': 'Português',
    'de': 'Deutsch'
}

# Define translations
TRANSLATIONS = {
    'en': {
        'import_btn': 'Import',
        'export_btn': 'Export',
        'send_reminder_btn': 'Send Reminder',
        'delete_btn': 'Delete',
        'add_comment_btn': 'Add Comment',
        'success': 'Success',
        'error': 'Error',
        'warning': 'Warning',
        'select_row': 'Please select a row first',
        'data_imported_successfully': 'Data imported successfully',
        'ready_status': 'Ready',
        'customer_region': 'Customer Region',
        'customer_name': 'Customer Name',
        'account_number': 'Account Number',
        'invoice_number': 'Invoice Number',
        'invoice_date': 'Invoice Date',
        'payment_terms': 'Payment Terms',
        'amount': 'Amount',
        'currency': 'Currency',
        'comments': 'Comments',
        'email_address': 'Email Address',
        'phone_number': 'Phone Number',
        'confirm_delete': 'Confirm Delete',
        'confirm_delete_message': 'Are you sure you want to delete the selected rows?',
        'data_loaded': 'Data loaded successfully',
        'data_exported_successfully': 'Data exported successfully',
        'undo_btn': 'Undo',
        'redo_btn': 'Redo',
        'filter_title': 'Filter - {column}',
        'search_label': 'Search:',
        'apply_btn': 'Apply',
        'cancel_btn': 'Cancel',
        'clear_btn': 'Clear',
        'invalid_file_format': 'Invalid file format'
    },
    'pl': {
        'import_btn': 'Importuj',
        'export_btn': 'Eksportuj',
        'send_reminder_btn': 'Wyślij przypomnienie',
        'delete_btn': 'Usuń',
        'add_comment_btn': 'Dodaj komentarz',
        'success': 'Sukces',
        'error': 'Błąd',
        'warning': 'Ostrzeżenie',
        'select_row': 'Proszę najpierw wybrać wiersz',
        'data_imported_successfully': 'Dane zaimportowane pomyślnie',
        'ready_status': 'Gotowy',
        'customer_region': 'Region klienta',
        'customer_name': 'Nazwa klienta',
        'account_number': 'Numer konta',
        'invoice_number': 'Numer faktury',
        'invoice_date': 'Data faktury',
        'payment_terms': 'Termin płatności',
        'amount': 'Kwota',
        'currency': 'Waluta',
        'comments': 'Komentarze',
        'email_address': 'Adres email',
        'phone_number': 'Numer telefonu',
        'confirm_delete': 'Potwierdź usunięcie',
        'confirm_delete_message': 'Czy jesteś pewien, że chcesz usunąć wybrane wiersze?',
        'data_loaded': 'Dane załadowane pomyślnie',
        'data_exported_successfully': 'Dane wyeksportowane pomyślnie',
        'undo_btn': 'Cofnij',
        'redo_btn': 'Ponów',
        'filter_title': 'Filtr - {column}',
        'search_label': 'Szukaj:',
        'apply_btn': 'Zastosuj',
        'cancel_btn': 'Anuluj',
        'clear_btn': 'Wyczyść',
        'invalid_file_format': 'Nieprawidłowy format pliku'
    },
    'es': {
        'import_btn': 'Importar',
        'export_btn': 'Exportar',
        'send_reminder_btn': 'Enviar Recordatorio',
        'delete_btn': 'Eliminar',
        'add_comment_btn': 'Añadir Comentario',
        'success': 'Éxito',
        'error': 'Error',
        'warning': 'Advertencia',
        'select_row': 'Por favor, seleccione una fila primero',
        'data_imported_successfully': 'Datos importados con éxito',
        'ready_status': 'Listo',
        'customer_region': 'Región del Cliente',
        'customer_name': 'Nombre del Cliente',
        'account_number': 'Número de Cuenta',
        'invoice_number': 'Número de Factura',
        'invoice_date': 'Fecha de Factura',
        'payment_terms': 'Términos de Pago',
        'amount': 'Importe',
        'currency': 'Moneda',
        'comments': 'Comentarios',
        'email_address': 'Correo Electrónico',
        'phone_number': 'Número de Teléfono',
        'confirm_delete': 'Confirmar Eliminación',
        'confirm_delete_message': '¿Está seguro de que desea eliminar las filas seleccionadas?',
        'data_loaded': 'Datos cargados con éxito',
        'data_exported_successfully': 'Datos exportados con éxito',
        'undo_btn': 'Deshacer',
        'redo_btn': 'Rehacer',
        'filter_title': 'Filtro - {column}',
        'search_label': 'Buscar:',
        'apply_btn': 'Aplicar',
        'cancel_btn': 'Cancelar',
        'clear_btn': 'Limpiar',
        'invalid_file_format': 'Formato de archivo inválido'
    },
    'fr': {
        'import_btn': 'Importer',
        'export_btn': 'Exporter',
        'send_reminder_btn': 'Envoyer Rappel',
        'delete_btn': 'Supprimer',
        'add_comment_btn': 'Ajouter Commentaire',
        'success': 'Succès',
        'error': 'Erreur',
        'warning': 'Avertissement',
        'select_row': 'Veuillez sélectionner une ligne d\'abord',
        'data_imported_successfully': 'Données importées avec succès',
        'ready_status': 'Prêt',
        'customer_region': 'Région du Client',
        'customer_name': 'Nom du Client',
        'account_number': 'Numéro de Compte',
        'invoice_number': 'Numéro de Facture',
        'invoice_date': 'Date de Facture',
        'payment_terms': 'Conditions de Paiement',
        'amount': 'Montant',
        'currency': 'Devise',
        'comments': 'Commentaires',
        'email_address': 'Adresse Email',
        'phone_number': 'Numéro de Téléphone',
        'confirm_delete': 'Confirmer la Suppression',
        'confirm_delete_message': 'Êtes-vous sûr de vouloir supprimer les lignes sélectionnées ?',
        'data_loaded': 'Données chargées avec succès',
        'data_exported_successfully': 'Données exportées avec succès',
        'undo_btn': 'Annuler',
        'redo_btn': 'Rétablir',
        'filter_title': 'Filtre - {column}',
        'search_label': 'Rechercher:',
        'apply_btn': 'Appliquer',
        'cancel_btn': 'Annuler',
        'clear_btn': 'Effacer',
        'invalid_file_format': 'Format de fichier invalide'
    },
    'it': {
        'import_btn': 'Importa',
        'export_btn': 'Esporta',
        'send_reminder_btn': 'Invia Promemoria',
        'delete_btn': 'Elimina',
        'add_comment_btn': 'Aggiungi Commento',
        'success': 'Successo',
        'error': 'Errore',
        'warning': 'Avviso',
        'select_row': 'Seleziona prima una riga',
        'data_imported_successfully': 'Dati importati con successo',
        'ready_status': 'Pronto',
        'customer_region': 'Regione Cliente',
        'customer_name': 'Nome Cliente',
        'account_number': 'Numero Conto',
        'invoice_number': 'Numero Fattura',
        'invoice_date': 'Data Fattura',
        'payment_terms': 'Termini di Pagamento',
        'amount': 'Importo',
        'currency': 'Valuta',
        'comments': 'Commenti',
        'email_address': 'Indirizzo Email',
        'phone_number': 'Numero di Telefono',
        'confirm_delete': 'Conferma Eliminazione',
        'confirm_delete_message': 'Sei sicuro di voler eliminare le righe selezionate?',
        'data_loaded': 'Dati caricati con successo',
        'data_exported_successfully': 'Dati esportati con successo',
        'undo_btn': 'Annulla',
        'redo_btn': 'Ripeti',
        'filter_title': 'Filtro - {column}',
        'search_label': 'Cerca:',
        'apply_btn': 'Applica',
        'cancel_btn': 'Annulla',
        'clear_btn': 'Cancella',
        'invalid_file_format': 'Formato file non valido'
    },
    'pt': {
        'import_btn': 'Importar',
        'export_btn': 'Exportar',
        'send_reminder_btn': 'Enviar Lembrete',
        'delete_btn': 'Excluir',
        'add_comment_btn': 'Adicionar Comentário',
        'success': 'Sucesso',
        'error': 'Erro',
        'warning': 'Aviso',
        'select_row': 'Por favor, selecione uma linha primeiro',
        'data_imported_successfully': 'Dados importados com sucesso',
        'ready_status': 'Pronto',
        'customer_region': 'Região do Cliente',
        'customer_name': 'Nome do Cliente',
        'account_number': 'Número da Conta',
        'invoice_number': 'Número da Fatura',
        'invoice_date': 'Data da Fatura',
        'payment_terms': 'Condições de Pagamento',
        'amount': 'Valor',
        'currency': 'Moeda',
        'comments': 'Comentários',
        'email_address': 'Endereço de Email',
        'phone_number': 'Número de Telefone',
        'confirm_delete': 'Confirmar Exclusão',
        'confirm_delete_message': 'Tem certeza que deseja excluir as linhas selecionadas?',
        'data_loaded': 'Dados carregados com sucesso',
        'data_exported_successfully': 'Dados exportados com sucesso',
        'undo_btn': 'Desfazer',
        'redo_btn': 'Refazer',
        'filter_title': 'Filtro - {column}',
        'search_label': 'Pesquisar:',
        'apply_btn': 'Aplicar',
        'cancel_btn': 'Cancelar',
        'clear_btn': 'Limpar',
        'invalid_file_format': 'Formato de arquivo inválido'
    },
    'de': {
        'import_btn': 'Importieren',
        'export_btn': 'Exportieren',
        'send_reminder_btn': 'Erinnerung senden',
        'delete_btn': 'Löschen',
        'add_comment_btn': 'Kommentar hinzufügen',
        'success': 'Erfolg',
        'error': 'Fehler',
        'warning': 'Warnung',
        'select_row': 'Bitte wählen Sie zuerst eine Zeile aus',
        'data_imported_successfully': 'Daten erfolgreich importiert',
        'ready_status': 'Bereit',
        'customer_region': 'Kundenregion',
        'customer_name': 'Kundenname',
        'account_number': 'Kontonummer',
        'invoice_number': 'Rechnungsnummer',
        'invoice_date': 'Rechnungsdatum',
        'payment_terms': 'Zahlungsbedingungen',
        'amount': 'Betrag',
        'currency': 'Währung',
        'comments': 'Kommentare',
        'email_address': 'E-Mail-Adresse',
        'phone_number': 'Telefonnummer',
        'confirm_delete': 'Löschen bestätigen',
        'confirm_delete_message': 'Sind Sie sicher, dass Sie die ausgewählten Zeilen löschen möchten?',
        'data_loaded': 'Daten erfolgreich geladen',
        'data_exported_successfully': 'Daten erfolgreich exportiert',
        'undo_btn': 'Rückgängig',
        'redo_btn': 'Wiederholen',
        'filter_title': 'Filter - {column}',
        'search_label': 'Suchen:',
        'apply_btn': 'Anwenden',
        'cancel_btn': 'Abbrechen',
        'clear_btn': 'Zurücksetzen',
        'invalid_file_format': 'Ungültiges Dateiformat'
    }
}

EMAIL_TRANSLATIONS = {
    'en': {
        'subject': 'Overdue Invoice Reminder: {invoice_number}',
        'greeting': 'Dear {customer_name},',
        'body': 'This is a reminder that your invoice {invoice_number} from {invoice_date} is overdue. The amount of {amount} {currency} is still outstanding. Please settle this as soon as possible.',
        'closing': 'Best regards,'
    },
    'pl': {
        'subject': 'Przypomnienie o przeterminowanej fakturze: {invoice_number}',
        'greeting': 'Szanowny {customer_name},',
        'body': 'To przypomnienie, że Twoja faktura {invoice_number} z {invoice_date} jest przeterminowana. Kwota {amount} {currency} wciąż pozostaje nieopłacona. Proszę uregulować tę należność jak najszybciej.',
        'closing': 'Pozdrawiam,'
    },
    'es': {
        'subject': 'Recordatorio de Factura Vencida: {invoice_number}',
        'greeting': 'Estimado {customer_name},',
        'body': 'Este es un recordatorio de que su factura {invoice_number} del {invoice_date} está vencida. El importe de {amount} {currency} aún está pendiente. Por favor, regularice este pago lo antes posible.',
        'closing': 'Atentamente,'
    },
    'fr': {
        'subject': 'Rappel de Facture Impayée : {invoice_number}',
        'greeting': 'Cher {customer_name},',
        'body': 'Ceci est un rappel concernant votre facture {invoice_number} du {invoice_date} qui est en retard de paiement. Le montant de {amount} {currency} reste dû. Merci de bien vouloir régulariser cette situation dans les plus brefs délais.',
        'closing': 'Cordialement,'
    },
    'it': {
        'subject': 'Promemoria Fattura Scaduta: {invoice_number}',
        'greeting': 'Gentile {customer_name},',
        'body': 'Questo è un promemoria per la sua fattura {invoice_number} del {invoice_date} che risulta scaduta. L\'importo di {amount} {currency} è ancora in sospeso. La preghiamo di provvedere al pagamento il prima possibile.',
        'closing': 'Cordialmente,'
    },
    'pt': {
        'subject': 'Lembrete de Fatura Vencida: {invoice_number}',
        'greeting': 'Prezado {customer_name},',
        'body': 'Este é um lembrete de que sua fatura {invoice_number} de {invoice_date} está vencida. O valor de {amount} {currency} ainda está pendente. Por favor, regularize este pagamento o mais breve possível.',
        'closing': 'Atenciosamente,'
    },
    'de': {
        'subject': 'Erinnerung an überfällige Rechnung: {invoice_number}',
        'greeting': 'Sehr geehrte(r) {customer_name},',
        'body': 'dies ist eine Erinnerung daran, dass Ihre Rechnung {invoice_number} vom {invoice_date} überfällig ist. Der Betrag von {amount} {currency} ist noch ausstehend. Bitte begleichen Sie diese Zahlung so schnell wie möglich.',
        'closing': 'Mit freundlichen Grüßen,'
    }
}

class CollectionApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        
        # Set window title and size
        self.title("ARMeS")
        self.geometry("1200x800")
        
        # Initialize variables
        self.df = None
        self.undo_stack = []
        self.redo_stack = []
        self.current_language = 'en'
        self.comments = {}
        
        # Inicjalizacja filtrów
        self.active_filters = {}  # słownik przechowujący aktywne filtry
        self.filter_history = []  # historia stanów filtrów do cofania
        self.filter_redo_history = []  # historia stanów filtrów do ponowienia
        
        # Create widgets
        self.create_widgets()
        
        # Configure row and column weights
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        
        # Bind events
        self.bind("<Control-z>", lambda e: self.undo_action())
        self.bind("<Control-y>", lambda e: self.redo_action())
        self.bind("<F2>", lambda e: self.edit_selected_cell())

    def get_translation(self, key):
        """Get translation for a given key"""
        try:
            return TRANSLATIONS[self.current_language][key]
        except KeyError:
            # Fallback to English if translation is missing
            try:
                return TRANSLATIONS['en'][key]
            except KeyError:
                return key

    def create_widgets(self):
        """Create all widgets for the application"""
        # Create main frame with custom colors
        self.main_frame = ctk.CTkFrame(self, fg_color="white", border_color="#ff9500", border_width=2)
        self.main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Create header frame
        header_frame = ctk.CTkFrame(self.main_frame, fg_color="white")
        header_frame.pack(fill="x", padx=5, pady=5)

        # Add centered header label
        self.header_label = ctk.CTkLabel(
            header_frame,
            text="AR Management System",
            font=("Helvetica", 20, "bold"),
            text_color="#ff9500"
        )
        self.header_label.pack(side="top", pady=10, expand=True)

        # Create language selection
        language_frame = ctk.CTkFrame(header_frame, fg_color="white")
        language_frame.pack(side="right", padx=5)

        # Create dictionary mapping full language names to codes
        self.language_names_to_codes = {LANGUAGE_NAMES[code]: code for code in LANGUAGE_NAMES.keys()}

        # Create language dropdown
        languages = [(LANGUAGE_NAMES[lang], lang) for lang in LANGUAGE_NAMES.keys()]
        language_menu = ctk.CTkOptionMenu(
            language_frame,
            values=[name for name, _ in languages],
            command=lambda name: self.on_language_change([code for n, code in languages if n == name][0])
        )
        language_menu.pack(side="right", padx=5)
        language_menu.set(LANGUAGE_NAMES[self.current_language])

        # Add language label
        language_label = ctk.CTkLabel(
            language_frame,
            text="Language:",
            font=("Helvetica", 10),
            text_color="#ff9500"
        )
        language_label.pack(side="right", padx=5)

        # Create buttons frame
        btn_frame = ctk.CTkFrame(self.main_frame, fg_color="white")
        btn_frame.pack(fill="x", padx=5, pady=5)

        # Import button
        self.import_button = ctk.CTkButton(
            btn_frame,
            text=self.get_translation('import_btn'),
            command=self.import_data,
            fg_color="#ff9500",
            hover_color="#ffab40"
        )
        self.import_button.pack(side="left", padx=5)

        # Send Reminder button
        self.reminder_button = ctk.CTkButton(
            btn_frame,
            text=self.get_translation('send_reminder_btn'),
            command=self.send_reminder,
            fg_color="#ff9500",
            hover_color="#ffab40"
        )
        self.reminder_button.pack(side="left", padx=5)

        # Delete button
        self.delete_button = ctk.CTkButton(
            btn_frame,
            text=self.get_translation('delete_btn'),
            command=self.delete_selected_row,
            fg_color="#FF6B6B",
            hover_color="#FF4444"
        )
        self.delete_button.pack(side="left", padx=5)

        # Add Comment button
        self.comment_button = ctk.CTkButton(
            btn_frame,
            text=self.get_translation('add_comment_btn'),
            command=self.show_comment_dialog,
            fg_color="#ff9500",
            hover_color="#ffab40"
        )
        self.comment_button.pack(side="left", padx=5)

        # Export button
        self.export_button = ctk.CTkButton(
            btn_frame,
            text=self.get_translation('export_btn'),
            command=self.export_to_excel,
            fg_color="#ff9500",
            hover_color="#ffab40"
        )
        self.export_button.pack(side="left", padx=5)

        # Undo button
        self.undo_button = ctk.CTkButton(
            btn_frame,
            text=self.get_translation('undo_btn'),
            command=self.undo_action,
            fg_color="#ff9500",
            hover_color="#ffab40"
        )
        self.undo_button.pack(side="left", padx=5)

        # Redo button
        self.redo_button = ctk.CTkButton(
            btn_frame,
            text=self.get_translation('redo_btn'),
            command=self.redo_action,
            fg_color="#ff9500",
            hover_color="#ffab40"
        )
        self.redo_button.pack(side="left", padx=5)

        # Create treeview
        self.create_treeview_and_comments()

        # Status bar
        self.status_var = tk.StringVar()
        self.status_var.set(self.get_translation('ready_status'))
        status_bar = ctk.CTkLabel(
            self.main_frame,
            textvariable=self.status_var,
            height=20,
            fg_color="white",
            text_color="#ff9500"
        )
        status_bar.pack(side="bottom", fill="x", padx=20)

        # Add footer
        footer_frame = ctk.CTkFrame(self.main_frame, fg_color="white", height=30)
        footer_frame.pack(fill="x", side="bottom", padx=20, pady=(10, 0))
        footer_frame.pack_propagate(False)  # Prevent frame from shrinking

        footer_text = ctk.CTkLabel(
            footer_frame,
            text="created by Szymon Grahl",
            font=("Helvetica", 8),
            text_color="#ff9500"
        )
        footer_text.pack(side="right", padx=10)

        # Bind keyboard shortcuts
        self.bind('<Control-c>', self.copy_selection)
        self.bind('<Control-x>', self.cut_selection)
        self.bind('<Control-v>', self.paste_selection)
        self.bind('<Control-a>', self.select_all)
        self.bind('<Control-f>', self.find_dialog)
        self.bind('<Delete>', lambda e: self.delete_selected_row())
        self.bind('<F2>', lambda e: self.edit_selected_cell())

    def edit_selected_cell(self, event=None):
        """Edit currently selected cell"""
        if event and event.type == '4':  # Double click event
            item = self.tree.identify_row(event.y)
            column = self.tree.identify_column(event.x)
        else:
            selected_items = self.tree.selection()
            if not selected_items:
                return
            item = selected_items[0]
            column = self._last_clicked_column if hasattr(self, '_last_clicked_column') else "#1"

        if item and column:
            column_name = self.tree["columns"][int(column[1]) - 1]
            self.edit_cell(item, column, column_name)

    def create_treeview_and_comments(self):
        # Create tree frame that fills the remaining space
        tree_frame = ctk.CTkFrame(self.main_frame)
        tree_frame.pack(fill="both", expand=True, padx=5, pady=5)

        # Inicjalizacja słownika filtrów
        self.active_filters = {}

        # Configure treeview style
        style = ttk.Style()
        style.configure("Treeview", 
                      background="white",
                      fieldbackground="white",
                      foreground="black",
                      rowheight=25)
        
        # Styl dla nagłówków z ikonami filtrów
        style.configure("Treeview.Heading",
                       padding=(20, 5))  # Dodaj padding dla miejsca na ikonę

        # Create scrollbar
        tree_scroll = ttk.Scrollbar(tree_frame)
        tree_scroll.pack(side="right", fill="y")

        # Create treeview
        self.tree = ttk.Treeview(
            tree_frame,
            columns=(
                "Customer Region", "Customer Name", "Account Number",
                "Invoice Number", "Invoice Date", "Payment Terms",
                "Amount", "Currency", "Comments", "Email address", "Phone number"
            ),
            show="headings",
            yscrollcommand=tree_scroll.set
        )
        
        # Configure tags for payment status colors
        self.tree.tag_configure('overdue', background="#FFB6C6")  # Light red
        self.tree.tag_configure('current', background="#90EE90")  # Light green
        self.tree.tag_configure('due_today', background="#FFFFE0")  # Light yellow

        # Configure scrollbars
        tree_scroll.configure(command=self.tree.yview)

        # Configure columns
        columns_config = {
            "Customer Region": {"text": self.get_translation('customer_region'), "width": 120},
            "Customer Name": {"text": self.get_translation('customer_name'), "width": 150},
            "Account Number": {"text": self.get_translation('account_number'), "width": 100},
            "Invoice Number": {"text": self.get_translation('invoice_number'), "width": 120},
            "Invoice Date": {"text": self.get_translation('invoice_date'), "width": 100},
            "Payment Terms": {"text": self.get_translation('payment_terms'), "width": 100},
            "Amount": {"text": self.get_translation('amount'), "width": 100},
            "Currency": {"text": self.get_translation('currency'), "width": 80},
            "Comments": {"text": self.get_translation('comments'), "width": 200},
            "Email address": {"text": self.get_translation('email_address'), "width": 200},
            "Phone number": {"text": self.get_translation('phone_number'), "width": 120}
        }

        # Utwórz ikonę filtra
        filter_icon = "▼"  # Unicode symbol for filter

        for col in self.tree["columns"]:
            # Dodaj tekst nagłówka z ikoną filtra
            header_text = f"{columns_config[col]['text']} {filter_icon}"
            self.tree.heading(col, 
                            text=header_text,
                            command=lambda c=col: self.show_filter(c))  # Dodaj obsługę kliknięcia
            self.tree.column(col, width=columns_config[col]["width"])

        # Pack treeview to fill the frame
        self.tree.pack(fill="both", expand=True)

        # Bind events for cell editing
        self.tree.bind('<Double-1>', self.edit_selected_cell)
        self.tree.bind('<Return>', self.edit_selected_cell)
        self.tree.bind('<Button-1>', self.on_tree_click)
        self.tree.bind('<F2>', self.edit_selected_cell)

    def on_tree_click(self, event):
        """Handle single click on treeview"""
        # Get the clicked column
        column = self.tree.identify_column(event.x)
        if column:
            self._last_clicked_column = column

    def edit_cell(self, item, column, column_name):
        """Create entry widget for cell editing"""
        # Save current state before editing
        self.save_current_state()

        # Get cell coordinates
        x, y, w, h = self.tree.bbox(item, column)
        
        # Get current value
        current_value = self.tree.item(item)['values'][int(column[1]) - 1]
        
        # Create and configure entry widget
        entry = ttk.Entry(self.tree, width=20)
        entry.place(x=x, y=y, width=w, height=h)
        entry.insert(0, current_value if current_value is not None else "")
        entry.select_range(0, tk.END)
        entry.focus()
        
        def on_entry_return(event):
            """Handle entry widget return key"""
            new_value = entry.get()
            values = list(self.tree.item(item)['values'])
            values[int(column[1]) - 1] = new_value
            self.tree.item(item, values=values)
            entry.destroy()
            self.recolor_rows()
            
        def on_entry_escape(event):
            """Handle entry widget escape key"""
            entry.destroy()
            
        def on_focus_out(event):
            """Handle entry widget focus out"""
            on_entry_return(event)
            
        entry.bind('<Return>', on_entry_return)
        entry.bind('<Escape>', on_entry_escape)
        entry.bind('<FocusOut>', on_focus_out)

    def load_data(self):
        """Load data from Excel file"""
        try:
            self.tree.delete(*self.tree.get_children())
            
            # Configure tags for payment status colors
            self.tree.tag_configure('overdue', background="#FFB6C6")  # Light red
            self.tree.tag_configure('current', background="#90EE90")  # Light green
            self.tree.tag_configure('due_today', background="#FFFFE0")  # Light yellow
            
            for index, row in self.df.iterrows():
                values = row.tolist()
                item = self.tree.insert("", "end", iid=str(index), values=values)
                
                try:
                    # Get invoice date and payment terms
                    invoice_date = pd.to_datetime(row['Invoice Date']).date()
                    payment_terms = int(str(row['Payment Terms']).replace('Net ', ''))
                    
                    # Calculate due date
                    due_date = invoice_date + pd.Timedelta(days=payment_terms)
                    
                    # Get current date
                    current_date = datetime.now().date()
                    
                    # Compare with current date
                    if due_date == current_date:
                        self.tree.item(item, tags=('due_today',))
                    elif due_date < current_date:
                        self.tree.item(item, tags=('overdue',))
                    else:
                        self.tree.item(item, tags=('current',))
                        
                except (ValueError, TypeError) as e:
                    print(f"Error processing dates for row {index}: {e}")
                    continue
            
            messagebox.showinfo(
                self.get_translation('success'),
                self.get_translation('data_loaded')
            )
        except Exception as e:
            messagebox.showerror(
                self.get_translation('error'),
                str(e)
            )

    def import_data(self):
        """Import data from Excel file"""
        file_path = filedialog.askopenfilename(
            filetypes=[("Excel files", "*.xlsx *.xls")]
        )
        if file_path:
            try:
                # Wczytaj nowe dane
                new_data = pd.read_excel(file_path)
                
                # Sprawdź czy kolumny się zgadzają
                expected_columns = [
                    "Customer Region", "Customer Name", "Account Number",
                    "Invoice Number", "Invoice Date", "Payment Terms",
                    "Amount", "Currency", "Comments", "Email address", "Phone number"
                ]
                
                if list(new_data.columns) != expected_columns:
                    messagebox.showerror(
                        self.get_translation('error'),
                        self.get_translation('invalid_file_format')
                    )
                    return
                
                # Jeśli nie ma jeszcze żadnych danych, po prostu załaduj nowe
                if self.df is None:
                    self.df = new_data
                else:
                    # Zapisz aktualny stan przed dodaniem nowych danych
                    self.save_current_state()
                    
                    # Połącz istniejące dane z nowymi
                    self.df = pd.concat([self.df, new_data], ignore_index=True)
                
                # Załaduj dane do widoku
                self.load_data()
                
                messagebox.showinfo(
                    self.get_translation('success'),
                    self.get_translation('data_imported_successfully')
                )
            except Exception as e:
                messagebox.showerror(
                    self.get_translation('error'),
                    str(e)
                )

    def export_to_excel(self):
        """Export data to Excel file"""
        try:
            # Get all items from the treeview
            data = []
            columns = [
                "Customer Region", "Customer Name", "Account Number",
                "Invoice Number", "Invoice Date", "Payment Terms",
                "Amount", "Currency", "Comments", "Email address", "Phone number"
            ]
            
            for item in self.tree.get_children():
                values = self.tree.item(item)['values']
                row_data = {}
                for col, value in zip(columns, values):
                    row_data[col] = value
                data.append(row_data)
            
            # Create DataFrame
            df = pd.DataFrame(data)
            
            # Ask user for save location
            file_path = filedialog.asksaveasfilename(
                defaultextension='.xlsx',
                filetypes=[
                    ("Excel files", "*.xlsx"),
                    ("All files", "*.*")
                ]
            )
            
            if not file_path:
                return
            
            # Export to Excel
            df.to_excel(file_path, index=False)
            
            self.status_var.set(self.get_translation('data_exported_successfully'))
            messagebox.showinfo(
                self.get_translation('success'),
                self.get_translation('data_exported_successfully')
            )
            
        except Exception as e:
            messagebox.showerror(
                self.get_translation('error'),
                f"Failed to export data: {str(e)}"
            )

    def delete_selected_row(self):
        """Delete selected row from treeview"""
        self.save_current_state()  # Zapisz stan przed usunięciem
        selected_items = self.tree.selection()
        
        if not selected_items:
            messagebox.showwarning(
                self.get_translation('warning'),
                self.get_translation('select_row_to_delete')
            )
            return
            
        if messagebox.askyesno(
            self.get_translation('confirm_delete'),
            self.get_translation('confirm_delete_message')
        ):
            # Delete selected items
            for item in selected_items:
                self.tree.delete(item)
            
            self.recolor_rows()
            
            self.status_var.set("Rows deleted successfully")

    def send_reminder(self):
        selected_items = self.tree.selection()
        if not selected_items:
            messagebox.showwarning(
                self.get_translation('warning'),
                self.get_translation('select_row')
            )
            return

        try:
            # Próba połączenia z aktywną sesją Outlooka
            try:
                outlook = win32com.client.GetActiveObject('Outlook.Application')
            except:
                # Jeśli nie ma aktywnej sesji, utworzenie nowej
                outlook = win32com.client.Dispatch('Outlook.Application')
            
            # Mapowanie języków na nazwy szablonów
            template_mapping = {
                'en': "Corza Medical - EN.oft",
                'pl': "Corza Medical - PL.oft",
                'es': "Corza Medical - ES.oft",
                'fr': "Corza Medical - FR.oft",
                'pt': "Corza Medical - PT.oft",
                'it': "Corza Medical - IT.oft",
                'de': "Corza Medical - DE.oft"
            }
            
            # Pobierz nazwę szablonu dla aktualnego języka
            template_name = template_mapping.get(self.current_language, "Corza Medical - EN.oft")
            template_path = os.path.join(os.path.dirname(__file__), template_name)
            
            if not os.path.exists(template_path):
                raise FileNotFoundError(f"Template '{template_name}' not found")
            
            for item in selected_items:
                values = self.tree.item(item)['values']
                customer_name = values[1]  # Customer Name
                invoice_number = values[3]  # Invoice Number
                invoice_date = values[4]  # Invoice Date
                amount = values[6]  # Amount
                currency = values[7]  # Currency
                email = values[9]  # Email address
                
                if not email:
                    messagebox.showwarning(
                        self.get_translation('warning'),
                        f"No email address for customer: {customer_name}"
                    )
                    continue
                
                try:
                    # Utworzenie maila z odpowiedniego szablonu językowego
                    mail_item = outlook.CreateItemFromTemplate(template_path)
                    mail_item.To = email
                    
                    # Zastąpienie placeholderów w temacie i treści
                    if hasattr(mail_item, 'HTMLBody'):
                        body = mail_item.HTMLBody
                    else:
                        body = mail_item.Body
                    
                    # Zamiana placeholderów na wartości
                    replacements = {
                        '{invoice_number}': str(invoice_number),
                        '{customer_name}': str(customer_name),
                        '{invoice_date}': str(invoice_date),
                        '{amount}': str(amount),
                        '{currency}': str(currency)
                    }
                    
                    for placeholder, value in replacements.items():
                        if hasattr(mail_item, 'HTMLBody'):
                            mail_item.HTMLBody = mail_item.HTMLBody.replace(placeholder, value)
                            mail_item.Subject = mail_item.Subject.replace(placeholder, value)
                        else:
                            mail_item.Body = mail_item.Body.replace(placeholder, value)
                            mail_item.Subject = mail_item.Subject.replace(placeholder, value)
                    
                    mail_item.Display()
                    
                except Exception as template_error:
                    messagebox.showerror(
                        self.get_translation('error'),
                        f"Error with template '{template_name}': {str(template_error)}"
                    )
                    continue
            
            messagebox.showinfo(
                self.get_translation('success'),
                "Reminder emails have been created"
            )
            
        except Exception as e:
            messagebox.showerror(
                self.get_translation('error'),
                f"Error creating reminder emails: {str(e)}")

    def show_comment_dialog(self):
        """Show dialog for adding/editing comments"""
        selected_items = self.tree.selection()
        if not selected_items:
            messagebox.showwarning(
                self.get_translation('warning'),
                self.get_translation('select_row')
            )
            return

        # Get the selected item
        item = selected_items[0]
        
        # Get current values
        values = list(self.tree.item(item)['values'])
        
        # Find the index of the Comments column
        comments_idx = self.tree["columns"].index("Comments")
        
        # Create entry dialog
        comment_dialog = tk.Toplevel(self)
        comment_dialog.title(self.get_translation('add_comment_btn'))
        comment_dialog.geometry("400x200")
        
        # Create and configure a text widget
        text_widget = tk.Text(comment_dialog, height=5, width=40)
        text_widget.pack(padx=10, pady=10, fill="both", expand=True)
        
        # Insert current comment if exists
        if values[comments_idx]:
            text_widget.insert("1.0", values[comments_idx])
        
        def save_comment():
            # Get the comment text
            new_comment = text_widget.get("1.0", "end-1c")
            
            # Update the values
            values[comments_idx] = new_comment
            
            # Update the tree
            self.tree.item(item, values=values)
            
            # Close the dialog
            comment_dialog.destroy()
        
        # Add save button
        save_btn = ctk.CTkButton(
            comment_dialog,
            text=self.get_translation('add_comment_btn'),
            command=save_comment,
            fg_color="#ff9500",
            hover_color="#ffab40"
        )
        save_btn.pack(pady=10)

    def copy_selection(self, event=None):
        """Copy selected rows to clipboard"""
        selected_items = self.tree.selection()
        if not selected_items:
            return
            
        # Get values for selected items
        clipboard_data = []
        for item in selected_items:
            values = self.tree.item(item)['values']
            clipboard_data.append(values)
            
        self.clipboard = clipboard_data
        
    def cut_selection(self, event=None):
        """Cut selected rows"""
        self.copy_selection()
        self.delete_selected_row()
        
    def paste_selection(self, event=None):
        """Paste rows from clipboard"""
        self.save_current_state()  # Zapisz stan przed wklejeniem
        if not self.clipboard:
            return
            
        # Insert clipboard data
        for values in self.clipboard:
            self.tree.insert('', 'end', values=values)

    def insert_today_date(self, event=None):
        """Insert today's date into the selected cell if it's in the Invoice Date column"""
        self.save_current_state()  # Zapisz stan przed zmianą daty
        selected_items = self.tree.selection()
        if not selected_items:
            return
            
        item = selected_items[0]
        column = self.tree.identify_column(event.x)
        
        # Check if it's the Invoice Date column (column #5)
        if column == "#5":
            # Get current values
            values = list(self.tree.item(item)['values'])
            
            # Update Invoice Date with today's date
            values[4] = datetime.now().strftime('%Y-%m-%d')
            
            # Update the row
            self.tree.item(item, values=values)
            
            self.recolor_rows()

    def clear_cell(self, event=None):
        """Clear the content of the selected cell"""
        self.save_current_state()  # Zapisz stan przed wyczyszczeniem
        selected_items = self.tree.selection()
        if not selected_items:
            return
            
        item = selected_items[0]
        column = self.tree.identify_column(event.x)
        
        if column:
            # Get current values
            values = list(self.tree.item(item)['values'])
            
            # Clear the selected cell
            col_index = int(column.replace('#', '')) - 1
            values[col_index] = ''
            
            # Update the row
            self.tree.item(item, values=values)
            
            self.recolor_rows()

    def select_all(self, event=None):
        """Select all rows in the treeview"""
        self.tree.selection_set(self.tree.get_children())

    def find_dialog(self, event=None):
        """Show dialog for finding text in treeview"""
        # Create dialog window
        dialog = tk.Toplevel(self)
        dialog.title("Find")
        dialog.geometry("300x100")
        
        # Create and pack widgets
        label = ttk.Label(dialog, text="Find what:")
        label.pack(pady=5)
        
        entry = ttk.Entry(dialog)
        entry.pack(pady=5)
        entry.focus_set()
        
        def find():
            search_text = entry.get().lower()
            if not search_text:
                return
                
            # Clear previous selection
            self.tree.selection_remove(self.tree.selection())
            
            # Search in all items
            found = False
            for item in self.tree.get_children():
                values = [str(v).lower() for v in self.tree.item(item)['values']]
                if any(search_text in value for value in values):
                    self.tree.selection_add(item)
                    found = True
            
            if not found:
                messagebox.showinfo("Find", "Text not found")
                
        # Create Find button
        find_btn = ttk.Button(dialog, text="Find", command=find)
        find_btn.pack(pady=5)

    def handle_arrow_key(self, event):
        """Handle arrow key navigation in treeview"""
        selection = self.tree.selection()
        if not selection:
            # If nothing is selected, select first item
            children = self.tree.get_children()
            if children:
                self.tree.selection_set(children[0])
            return
            
        current = selection[0]
        if event.keysym == 'Up':
            prev = self.tree.prev(current)
            if prev:
                self.tree.selection_set(prev)
        elif event.keysym == 'Down':
            next = self.tree.next(current)
            if next:
                self.tree.selection_set(next)
        elif event.keysym in ('Left', 'Right'):
            pass  # Do nothing for left/right arrows
            
        return "break"  # Prevent default handling

    def handle_return(self, event):
        """Handle return key press in treeview"""
        selection = self.tree.selection()
        if selection:
            self.show_comment_dialog()
        return "break"  # Prevent default handling

    def handle_tab(self, event):
        """Handle tab key press in treeview"""
        selection = self.tree.selection()
        if not selection:
            # If nothing is selected, select first item
            children = self.tree.get_children()
            if children:
                self.tree.selection_set(children[0])
            return "break"
            
        current = selection[0]
        next = self.tree.next(current)
        if next:
            self.tree.selection_set(next)
        return "break"  # Prevent default handling
        
    def handle_shift_tab(self, event):
        """Handle shift+tab key press in treeview"""
        selection = self.tree.selection()
        if not selection:
            # If nothing is selected, select last item
            children = self.tree.get_children()
            if children:
                self.tree.selection_set(children[-1])
            return "break"
            
        current = selection[0]
        prev = self.tree.prev(current)
        if prev:
            self.tree.selection_set(prev)
        return "break"  # Prevent default handling

    def on_language_change(self, language_code):
        """Handle language change"""
        self.current_language = language_code
        
        # Update buttons text
        self.import_button.configure(text=self.get_translation('import_btn'))
        self.export_button.configure(text=self.get_translation('export_btn'))
        self.reminder_button.configure(text=self.get_translation('send_reminder_btn'))
        self.delete_button.configure(text=self.get_translation('delete_btn'))
        self.comment_button.configure(text=self.get_translation('add_comment_btn'))
        self.undo_button.configure(text=self.get_translation('undo_btn'))
        self.redo_button.configure(text=self.get_translation('redo_btn'))
        
        # Update column headers
        for col, translation_key in [
            ("Customer Region", 'customer_region'),
            ("Customer Name", 'customer_name'),
            ("Account Number", 'account_number'),
            ("Invoice Number", 'invoice_number'),
            ("Invoice Date", 'invoice_date'),
            ("Payment Terms", 'payment_terms'),
            ("Amount", 'amount'),
            ("Currency", 'currency'),
            ("Comments", 'comments'),
            ("Email address", 'email_address'),
            ("Phone number", 'phone_number')
        ]:
            # Utwórz ikonę filtra
            filter_icon = "▼"  # Unicode symbol for filter
            header_text = f"{self.get_translation(translation_key)} {filter_icon}"
            self.tree.heading(col, text=header_text)

    def recolor_rows(self):
        """Recolor rows based on payment status"""
        for item in self.tree.get_children():
            try:
                # Get invoice date and payment terms
                invoice_date = pd.to_datetime(self.tree.set(item, "Invoice Date")).date()
                payment_terms = int(str(self.tree.set(item, "Payment Terms")).replace('Net ', ''))
                
                # Calculate due date
                due_date = invoice_date + pd.Timedelta(days=payment_terms)
                
                # Get current date
                current_date = datetime.now().date()
                
                # Compare with current date
                if due_date == current_date:
                    self.tree.item(item, tags=('due_today',))
                elif due_date < current_date:
                    self.tree.item(item, tags=('overdue',))
                else:
                    self.tree.item(item, tags=('current',))
                    
            except (ValueError, TypeError) as e:
                print(f"Error processing dates for row {item}: {e}")
                continue

    def save_filter_state(self):
        """Zapisuje aktualny stan filtrów na stosie historii"""
        current_state = self.active_filters.copy()
        self.filter_history.append(current_state)
        self.filter_redo_history.clear()  # Czyścimy historię redo po nowej akcji
        self.update_undo_redo_buttons()

    def restore_state(self, state):
        """Przywraca zapisany stan aplikacji"""
        # Usuń wszystkie wiersze z drzewa
        for item in self.tree.get_children():
            self.tree.delete(item)
            
        # Przywróć wiersze
        for values in state['rows']:
            self.tree.insert('', 'end', values=values)
            
        # Przywróć komentarze
        self.comments = state['comments'].copy()
        
        # Odśwież kolory
        self.recolor_rows()

    def save_current_state(self):
        """Zapisuje aktualny stan aplikacji na stosie undo"""
        current_state = {
            'rows': [],
            'filters': self.active_filters.copy() if self.active_filters else {},
        }
        
        # Save all rows from treeview
        for item in self.tree.get_children():
            values = self.tree.item(item)['values']
            tags = self.tree.item(item)['tags']
            current_state['rows'].append({
                'values': values,
                'tags': tags
            })
        
        self.undo_stack.append(current_state)
        self.redo_stack.clear()  # Clear redo stack when new action is performed
        self.update_undo_redo_buttons()

    def undo_action(self):
        """Cofa ostatnią akcję"""
        if len(self.filter_history) > 1:  # Musi być więcej niż 1 stan w historii filtrów
            # Zdejmij aktualny stan i dodaj go do historii redo
            current_state = self.filter_history.pop()
            self.filter_redo_history.append(current_state)
            
            # Przywróć poprzedni stan filtrów
            self.active_filters = self.filter_history[-1].copy()
            self.apply_filters()
        elif self.undo_stack:  # Jeśli nie ma filtrów do cofnięcia, spróbuj cofnąć zmiany w danych
            current_state = {
                'rows': [],
                'filters': self.active_filters.copy(),
                'comments': self.comments.copy()
            }
            self.redo_stack.append(current_state)
            previous_state = self.undo_stack.pop()
            self.restore_state(previous_state)
        
        self.update_undo_redo_buttons()

    def redo_action(self):
        """Ponawia ostatnio cofniętą akcję"""
        if self.filter_redo_history:  # Najpierw sprawdź czy są cofnięte filtry
            # Zapisz aktualny stan do historii
            current_state = self.active_filters.copy()
            self.filter_history.append(current_state)
            
            # Przywróć następny stan z historii redo
            next_state = self.filter_redo_history.pop()
            self.active_filters = next_state
            self.apply_filters()
        elif self.redo_stack:  # Jeśli nie ma filtrów do ponowienia, spróbuj ponowić zmiany w danych
            current_state = {
                'rows': [],
                'filters': self.active_filters.copy(),
                'comments': self.comments.copy()
            }
            self.undo_stack.append(current_state)
            next_state = self.redo_stack.pop()
            self.restore_state(next_state)
        
        self.update_undo_redo_buttons()

    def update_undo_redo_buttons(self):
        """Aktualizuje stan przycisków undo/redo"""
        # Sprawdź czy są akcje do cofnięcia (w historii filtrów lub danych)
        can_undo = len(self.filter_history) > 1 or bool(self.undo_stack)
        self.undo_button.configure(state='normal' if can_undo else 'disabled')
        
        # Sprawdź czy są akcje do ponowienia (w historii filtrów lub danych)
        can_redo = bool(self.filter_redo_history) or bool(self.redo_stack)
        self.redo_button.configure(state='normal' if can_redo else 'disabled')

    def show_filter(self, column):
        """Pokazuje okno filtrowania dla wybranej kolumny"""
        # Pobierz pozycję kursora myszy
        x = self.winfo_pointerx()
        y = self.winfo_pointery()
        
        # Pobierz unikalne wartości z kolumny
        unique_values = set()
        for item in self.tree.get_children():
            value = self.tree.set(item, column)
            if value:  # Dodaj tylko niepuste wartości
                unique_values.add(value)
                
        # Funkcja do aplikowania filtra
        def apply_filter(selected_values):
            if not selected_values:  # Jeśli lista jest pusta, usuń filtr
                if column in self.active_filters:
                    del self.active_filters[column]
            else:
                self.active_filters[column] = selected_values
            
            self.apply_filters()  # Zastosuj wszystkie aktywne filtry
            
        # Pokaż okno filtra
        filter_window = FilterWindow(self, column, unique_values, x, y, apply_filter)
        filter_window.focus_force()

    def apply_filters(self):
        """Aplikuje wszystkie aktywne filtry na danych"""
        if self.df is None:
            return
            
        # Najpierw ukryj wszystkie wiersze
        for item in self.tree.get_children():
            self.tree.detach(item)
            
        # Jeśli nie ma aktywnych filtrów, pokaż wszystkie wiersze
        if not self.active_filters:
            # Przywróć wszystkie wiersze z DataFrame
            for idx, row in self.df.iterrows():
                values = row.tolist()
                try:
                    # Próbuj przywrócić istniejący wiersz
                    self.tree.reattach(str(idx), '', 'end')
                except tk.TclError:
                    # Jeśli wiersz nie istnieje, utwórz nowy
                    self.tree.insert('', 'end', iid=str(idx), values=values)
        else:
            # Pokaż tylko wiersze spełniające kryteria filtrowania
            for idx, row in self.df.iterrows():
                show_item = True
                for column, allowed_values in self.active_filters.items():
                    item_value = str(row[column])
                    if item_value not in allowed_values:
                        show_item = False
                        break
                
                if show_item:
                    try:
                        # Próbuj przywrócić istniejący wiersz
                        self.tree.reattach(str(idx), '', 'end')
                    except tk.TclError:
                        # Jeśli wiersz nie istnieje, utwórz nowy
                        values = row.tolist()
                        self.tree.insert('', 'end', iid=str(idx), values=values)
        
        # Odśwież kolory
        self.recolor_rows()

    def restore_all_rows(self):
        """Przywraca wszystkie wiersze do drzewa"""
        if self.df is None:
            return
            
        # Usuń wszystkie istniejące wiersze
        for item in self.tree.get_children():
            self.tree.delete(item)
            
        # Dodaj wszystkie wiersze z DataFrame
        for idx, row in self.df.iterrows():
            values = row.tolist()
            self.tree.insert('', 'end', iid=str(idx), values=values)
            
        self.recolor_rows()

class FilterWindow(tk.Toplevel):
    def __init__(self, parent, column, unique_values, x, y, apply_filter):
        super().__init__(parent)
        self.parent_app = parent  # Zachowaj referencję do głównej aplikacji
        self.title(self.get_translation('filter_title').format(column=column))
        self.geometry(f"+{x}+{y}")  # Ustaw pozycję okna
        
        # Konfiguracja okna
        self.transient(parent)  # Okno będzie zawsze na wierzchu rodzica
        self.grab_set()  # Przechwyć wszystkie zdarzenia
        
        # Zachowaj referencje
        self.column = column
        self.apply_filter = apply_filter
        
        # Ramka główna
        self.frame = ttk.Frame(self)
        self.frame.pack(padx=5, pady=5, fill='both', expand=True)
        
        # Pole wyszukiwania
        self.search_var = tk.StringVar()
        self.search_var.trace('w', self.filter_listbox)
        search_frame = ttk.Frame(self.frame)
        search_frame.pack(fill='x', padx=5, pady=5)
        ttk.Label(search_frame, text=self.get_translation('search_label')).pack(side='left', padx=(0,5))
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var)
        self.search_entry.pack(side='left', fill='x', expand=True)
        
        # Lista wartości
        self.listbox_frame = ttk.Frame(self.frame)
        self.listbox_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        self.listbox = tk.Listbox(self.listbox_frame, selectmode='multiple', height=10)
        self.listbox.pack(side='left', fill='both', expand=True)
        
        # Scrollbar dla listy
        scrollbar = ttk.Scrollbar(self.listbox_frame, orient="vertical", command=self.listbox.yview)
        scrollbar.pack(side='right', fill='y')
        self.listbox.configure(yscrollcommand=scrollbar.set)
        
        # Przyciski
        button_frame = ttk.Frame(self.frame)
        button_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Button(button_frame, text=self.get_translation('apply_btn'), command=self.apply_and_close).pack(side='left', padx=2)
        ttk.Button(button_frame, text=self.get_translation('cancel_btn'), command=self.destroy).pack(side='left', padx=2)
        ttk.Button(button_frame, text=self.get_translation('clear_btn'), command=self.clear_and_apply).pack(side='left', padx=2)
        
        # Wypełnij listę unikalnymi wartościami
        self.unique_values = sorted(unique_values)
        for value in self.unique_values:
            self.listbox.insert(tk.END, str(value))
            
    def filter_listbox(self, *args):
        search_term = self.search_var.get().lower()
        self.listbox.delete(0, tk.END)
        
        for value in self.unique_values:
            if search_term in str(value).lower():
                self.listbox.insert(tk.END, str(value))
                
    def clear_and_apply(self):
        """Czyści filtr dla aktualnej kolumny"""
        self.apply_filter([])  # Przekazujemy pustą listę, aby usunąć filtr
        self.destroy()
        
    def apply_and_close(self):
        """Aplikuje wybrane wartości filtra i zamyka okno"""
        selected_indices = self.listbox.curselection()
        selected_values = [self.listbox.get(i) for i in selected_indices]
        self.apply_filter(selected_values)
        self.destroy()

    def get_translation(self, key):
        """Get translation for a given key"""
        return TRANSLATIONS[self.parent_app.current_language][key]

if __name__ == "__main__":
    app = CollectionApp()
    app.mainloop()
